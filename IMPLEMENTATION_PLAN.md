# План реализации монолитного приложения FootPath

## Общая цель
Создать монолитное приложение, объединяющее все функциональные возможности системы FootPath в одном NestJS-приложении с использованием нескольких баз данных, подготовленное для быстрого запуска через Docker Compose и обеспечивающее подробное логирование для отладки.

## Принципы проектирования
1. Все модули объединены в одном приложении NestJS
2. Используются разные базы данных для разных задач (PostgreSQL/PostGIS, Neo4j)
3. Каждая задача должна быть независимой и выполнимой без контекста предыдущих задач
4. Система должна включать подробное логирование для отладки

---

## Фаза 1: Настройка базовой инфраструктуры

### Задача 1: Создание основной структуры проекта
- Создать базовую структуру NestJS-приложения
- Настроить основные конфигурационные файлы (package.json, tsconfig.json, nest-cli.json)
- Установить необходимые зависимости для монолита (NestJS, TypeORM, PostgreSQL, Redis, Winston)
- Создать основную архитектуру модулей (app.module.ts)

### Задача 2: Настройка файла Docker Compose
- Создать docker-compose.yml для запуска всех необходимых сервисов:
  - Основное NestJS-приложение
  - PostgreSQL с PostGIS
  - Neo4j
  - Redis
- Настроить правильные зависимости между сервисами
- Определить порты и volumes для persistence

### Задача 3: Настройка Dockerfile для монолита
- Создать Dockerfile для основного приложения
- Убедиться, что все зависимости установлены корректно
- Настроить сборку и запуск приложения в контейнере

### Задача 4: Настройка системы логирования
- Интегрировать библиотеку Winston для логирования
- Настроить логирование разных уровней (info, warn, error, debug)
- Настроить логирование в файл и консоль
- Реализовать структурированное логирование с метками времени

---

## Фаза 2: Реализация модуля аутентификации

### Задача 5: Создание модуля аутентификации
- Создать сущность User с полями: id, email, password, role, createdAt, updatedAt
- Реализовать модели DTO (RegisterDto, LoginDto, UserProfileDto)
- Создать базовую логику хеширования паролей
- Реализовать JWT-аутентификацию

### Задача 6: Реализация регистрации и входа
- Реализовать контроллер AuthController с эндпоинтами:
  - POST /auth/register
  - POST /auth/login
  - POST /auth/logout
  - GET /auth/me
- Добавить валидацию входных данных
- Интегрировать с базой данных PostgreSQL

### Задача 7: Реализация управления профилем
- Реализовать обновление профиля пользователя
- Добавить эндпоинт PUT /auth/profile
- Реализовать валидацию и безопасность обновления данных
- Добавить логирование операций с профилем

### Задача 8: Реализация восстановления пароля
- Создать функционал сброса пароля через email
- Реализовать генерацию и валидацию токенов
- Добавить эндпоинты для запроса сброса и сброса пароля

---

## Фаза 3: Реализация модуля мест (POI)

### Задача 9: Создание сущностей для модуля мест
- Создать сущность Place с полями: id, name, description, coordinates, tags, status, moderatorId, createdAt, etc.
- Создать сущность Tag для тегов мест
- Создать сущность PlaceModerationLog для истории модерации
- Настроить связи между сущностями

### Задача 10: Реализация CRUD-операций для мест
- Создать PlaceController с эндпоинтами:
  - POST /places (создание места)
  - GET /places (поиск с фильтрацией по радиусу, тегам, статусу)
  - GET /places/:id (получение конкретного места)
  - PUT /places/:id (обновление места)
- Реализовать геопространственные запросы через PostGIS

### Задача 11: Реализация системы модерации
- Добавить логику статусов мест (pending, approved, rejected)
- Реализовать эндпоинт для модераторов PUT /places/:id/approve
- Добавить логирование модерационных действий
- Реализовать валидацию прав доступа

### Задача 12: Реализация поиска мест по координатам
- Реализовать геопространственные запросы
- Добавить возможность поиска мест в радиусе от заданных координат
- Оптимизировать запросы с использованием геоиндексов

---

## Фаза 4: Реализация модуля друзей

### Задача 13: Интеграция Neo4j для социальных связей
- Установить драйвер Neo4j для Node.js
- Настроить подключение к Neo4j из NestJS-приложения
- Создать конфигурацию для работы с графовой базой данных

### Задача 14: Реализация сущностей социальных связей
- Создать сущность FriendRequest с полями: id, senderId, receiverId, status, createdAt
- Реализовать модели DTO для работы с друзьями
- Создать Cypher-запросы для работы с графом дружбы

### Задача 15: Реализация основных функций дружбы
- Создать FriendsController с эндпоинтами:
  - GET /friends (получить список друзей)
  - POST /friends/requests (отправить запрос в друзья)
  - POST /friends/requests/:id/accept (принять запрос)
  - DELETE /friends/:userId (удалить из друзей)
  
### Задача 16: Реализация запросов и уведомлений о дружбе
- Добавить логику обработки запросов в друзья
- Реализовать проверку статуса запросов
- Добавить валидацию и безопасность операций

---

## Фаза 5: Реализация модуля маршрутов

### Задача 17: Создание сущностей для маршрутов
- Создать сущность Path с полями: id, name, description, places (связь с Place), distance, totalTime, createdAt
- Создать сущность PathPlace для связи путей и мест
- Реализовать модели DTO для маршрутов

### Задача 18: Реализация алгоритма генерации маршрутов
- Создать сервис построения оптимальных маршрутов
- Реализовать алгоритм с учетом времени нахождения в местах и времени пути между ними
- Учесть географические ограничения и пешеходные маршруты

### Задача 19: Реализация CRUD-операций для маршрутов
- Создать PathController с эндпоинтами:
  - POST /paths/generate (генерация маршрута по параметрам)
  - POST /paths (создание сохраненного маршрута)
  - GET /paths/:id (получение маршрута)
  - GET /paths (поиск маршрутов)
- Реализовать валидацию параметров генерации

---

## Фаза 6: Реализация модуля прогулок

### Задача 20: Создание сущностей для прогулок
- Создать сущность Walk с полями: id, title, pathId, startTime, endTime, participants, status, creatorId, createdAt
- Создать сущность WalkParticipant для связи прогулок и участников
- Реализовать модели DTO для прогулок

### Задача 21: Реализация основных функций прогулок
- Создать WalkController с эндпоинтами:
  - POST /walks (создание прогулки)
  - GET /walks (получение списка прогулок)
  - GET /walks/:id (получение деталей прогулки)
  - POST /walks/:id/invite (приглашение участников)
  - POST /walks/:id/complete (завершение прогулки)

### Задача 22: Реализация приглашений на прогулки
- Реализовать логику приглашения друзей на прогулки
- Добавить статусы участников (pending, confirmed, declined)
- Реализовать уведомления о приглашениях

### Задача 23: Реализация завершения прогулок
- Добавить логику завершения прогулок
- Реализовать обновление статистики участников
- Сохранить историю посещенных мест для рекомендательной системы

---

## Фаза 7: Реализация модуля уведомлений

### Задача 24: Создание сущностей для уведомлений
- Создать сущность Notification с полями: id, userId, type, title, message, isRead, createdAt
- Реализовать типы уведомлений (friend_request, walk_invitation, place_moderation)
- Создать модели DTO для уведомлений

### Задача 25: Реализация отправки и получения уведомлений
- Создать NotificationController с эндпоинтами:
  - GET /notifications (получить все уведомления пользователя)
  - POST /notifications/:id/read (отметить как прочитанное)
  - POST /notifications/bulk-read (отметить несколько как прочитанные)
- Реализовать систему отправки уведомлений из других модулей

---

## Фаза 8: Реализация рекомендательной системы

### Задача 26: Настройка PostgreSQL с pgvector
- Включить расширение pgvector в PostgreSQL
- Создать сущность PlaceEmbedding для хранения векторных представлений мест
- Настроить индексы для быстрого поиска ближайших векторов

### Задача 27: Интеграция Python для ML
- Добавить Python-скрипты для генерации эмбеддингов
- Реализовать вызов Python-скриптов из NestJS
- Настроить передачу данных между Node.js и Python частями

### Задача 28: Реализация генерации векторных представлений
- Создать сервис для генерации эмбеддингов мест на основе текстового описания и тегов
- Реализовать сохранение векторных представлений в базу данных
- Создать триггеры на одобрение мест для генерации эмбеддингов

### Задача 29: Реализация системы рекомендаций
- Создать RecommendationController с эндпоинтами:
  - GET /recommendations/places (получить рекомендованные места)
  - GET /recommendations/paths (получить рекомендованные маршруты)
- Реализовать алгоритмы рекомендаций на основе:
  - Истории посещенных мест
  - Векторного сходства
  - Социальных связей

---

## Фаза 9: Интеграция и тестирование

### Задача 30: Интеграция всех модулей
- Объединить все модули в едином приложении
- Обеспечить корректную работу связей между модулями
- Настроить зависимости и внедрение зависимостей

### Задача 31: Настройка API Gateway
- Реализовать единый интерфейс для всех сервисов
- Добавить документацию Swagger/OpenAPI
- Настроить CORS и безопасность


### Задача 33: Настройка кеширования с Redis
- Настроить Redis для кеширования частых запросов
- Реализовать кеширование результатов поиска мест
- Добавить кеширование сессий пользователей

---

## Фаза 10: Документация и финальные настройки

### Задача 34: Создание документации API
- Настроить генерацию документации Swagger
- Добавить описания ко всем эндпоинтам
- Включить примеры запросов и ответов

### Задача 35: Финальное тестирование и отладка
- Провести комплексное тестирование всех функций
- Проверить работу с различными базами данных
- Протестировать сценарии использования

### Задача 36: Подготовка к деплою
- Оптимизировать Docker-файлы и конфигурацию
- Добавить скрипты для первоначальной настройки баз данных
- Подготовить документацию по развёртыванию